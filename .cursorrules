Saturn is a Jupyter-like interactive notebook environment for TypeScript, featuring:

* Reactive notebook cells for real-time code execution
* Modern web interface built with React
* Monaco Editor for a powerful code editing experience
* State management powered by Legend App State
* Clean, responsive design using Tailwind CSS

// we need to make sure that only one export per code block is possible

// INSTRUCTION SET FOR BUILDING REACT CODE RUNNER

/*
KEY COMPONENTS NEEDED:

1. Core Module Resolution System
2. Type System Integration 
3. Code Transformation Pipeline
4. Execution Environment
5. Error Handling
*/

// 1. Module Resolution
interface ModuleCache {
  [key: string]: any; 
}

class ModuleResolver {
  private cache: ModuleCache = {}; 

  async resolveModule(specifier: string): Promise<any> {

    if (this.cache[specifier]) return this.cache[specifier];
    
    const esmUrl = `https://esm.sh/${specifier}` ;
    try {
      const module = await import(/* @vite-ignore */ esmUrl);
      this.cache[specifier] = module;
      return module;
    } catch (error) {
      throw new Error( `Failed to load module: ${specifier}` );
    }

  }
}

// 2. Type System 
interface TypeRegistry {
  [key: string]: string; 
}

class TypeLoader {
  private typeCache: TypeRegistry = {}; 

  async loadTypes(module: string): Promise<string> {

    if (this.typeCache[module]) return this.typeCache[module];

    try {
      // Try DefinitelyTyped first
      const dtUrl = `https://cdn.jsdelivr.net/npm/@types/${module}/index.d.ts` ;
      const res = await fetch(dtUrl);
      if (res.ok) {
        const types = await res.text();
        this.typeCache[module] = types;
        return types;
      }

      // Fallback to esm.sh types
      const esmTypesUrl = `https://esm.sh/${module}?types` ;
      const esmRes = await fetch(esmTypesUrl);
      const types = await esmRes.text();
      this.typeCache[module] = types;
      return types;
    } catch (error) {
      throw new Error( `Failed to load types for ${module}` );
    }

  }
}

// 3. Code Transform Pipeline
interface TransformOptions {
  typescript?: boolean; 
  jsx?: boolean; 
}

class CodeTransformer {
  transform(code: string, options: TransformOptions = {}) {

    // Use Sucrase for transformation
    return transform(code, {
      transforms: [
        ...(options.typescript ? ['typescript'] : []),
        ...(options.jsx ? ['jsx'] : []),
        'imports'
      ],
      production: true
    }).code;

  }
}

// 4. Execution Environment
class CodeRunner {
  private moduleResolver: ModuleResolver; 
  private typeLoader: TypeLoader; 
  private transformer: CodeTransformer; 

  constructor() {

    this.moduleResolver = new ModuleResolver();
    this.typeLoader = new TypeLoader();
    this.transformer = new CodeTransformer();

  }

  async execute(code: string, scope = {}) {

    // 1. Extract imports
    const imports = this.extractImports(code);
    
    // 2. Load modules
    const modules = await Promise.all(
      imports.map(imp => this.moduleResolver.resolveModule(imp))
    );

    // 3. Transform code
    const transformed = this.transformer.transform(code, {
      typescript: true,
      jsx: true
    });

    // 4. Execute with scope
    const fn = new Function(...Object.keys(scope), transformed);
    return fn(...Object.values(scope));

  }

  private extractImports(code: string): string[] {

    const importRegex = /import\s+?(?:(?:(?:[\w*\s{},]*)\s+from\s+?)|)(?:(?:".*?")|(?:'.*?'))[\s]*?(?:;|$)/g;
    const matches = code.match(importRegex) || [];
    return matches.map(imp => {
      const [_, module] = imp.match(/['"]([^'"]+)['"]/) || [];
      return module;
    }).filter(Boolean);

  }
}

// USAGE EXAMPLE:

const runner = new CodeRunner(); 

const code = `
import React from 'react'; 
import Select from 'react-select'; 

export default function Demo() {
  const [value, setValue] = React.useState(null); 
  
  return (

    <Select
      value={value}
      onChange={setValue}
      options={[
        { value: 'chocolate', label: 'Chocolate' },
        { value: 'strawberry', label: 'Strawberry' },
        { value: 'vanilla', label: 'Vanilla' }
      ]}
    />

  ); 
}
`; 

// Execute with React in scope
runner.execute(code, { React }).then(result => {
  console.log('Execution complete:', result); 
}).catch(error => {
  console.error('Execution failed:', error); 
}); 
